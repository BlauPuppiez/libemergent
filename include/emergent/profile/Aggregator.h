#pragma once

#include <emergent/concurrentqueue.h>
#include <emergent/profile/Storage.hpp>

namespace emergent
{
	namespace profile
	{
		class Aggregator
		{
			public:

				/// Accessor for the singleton instance
				static Aggregator &Instance();

				/// Initialise with a process specific ID (to prevent overwriting of statistics
				/// generated by multiple applications using the profiler). Specify the type of
				/// storage required and how long between aggregations (ms).
				bool Initialise(std::string id, std::unique_ptr<Storage> storage, long poll = 1000);

				/// Push a single reading to the aggregrator. This is pushed onto a concurrent
				/// queue to try and avoid situations where the profiler itself is impeding
				/// performance.
				void Push(std::string name, long time);

			private:

				/// Simple structure used for queueing individual readings
				struct Reading
				{
					std::string name;	// Unique name for this reading
					long time;			// Time taken in us
				};

				Aggregator(); 								// Prevent instantiation
				Aggregator(Aggregator const&);				// Prevent copy construction
				Aggregator& operator=(Aggregator const&);	// Prevent assignment
				~Aggregator();

				void Entry();


				moodycamel::ConcurrentQueue<Reading> queue;	// Temporary buffer for the incoming data
				std::unique_ptr<Storage> storage;			// Where to write the aggregations
				Aggregation aggregation;					// Current aggregated results
				std::string id;								// Name of this application (aggregator is a singleton, so one instance per process)
				long poll;									// Poll time for aggregating results (ms)

				std::thread thread;							// Thread on which to generate and store the results
				std::atomic<bool> run;
		};
	}
}
